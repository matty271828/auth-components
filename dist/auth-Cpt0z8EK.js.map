{"version":3,"file":"auth-Cpt0z8EK.js","sources":["../src/lib/utils.ts","../src/lib/auth.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n\n// Common passwords to check against\nconst COMMON_PASSWORDS = [\n  'password', '123456', '123456789', 'qwerty', 'abc123', 'password123',\n  'admin', 'letmein', 'welcome', 'monkey', 'dragon', 'master', 'sunshine',\n  'princess', 'qwerty123', 'football', 'baseball', 'superman', 'batman',\n  'trustno1', 'hello123', 'freedom', 'whatever', 'qazwsx', 'password1',\n  '12345678', '1234567', '123123', '111111', '000000', 'qwertyuiop',\n  'asdfghjkl', 'zxcvbnm', '1q2w3e4r', '1qaz2wsx', 'q1w2e3r4', 'abcd1234'\n];\n\nexport interface PasswordRequirement {\n  id: string;\n  label: string;\n  test: (password: string) => boolean;\n  met: boolean;\n}\n\nexport interface PasswordStrength {\n  score: number; // 0-5\n  label: string;\n  color: string;\n  requirements: PasswordRequirement[];\n}\n\n/**\n * Check if password contains sequential patterns\n */\nfunction hasSequentialPatterns(password: string): boolean {\n  const sequences = [\n    '123456', '234567', '345678', '456789', '567890',\n    'abcdef', 'bcdefg', 'cdefgh', 'defghi', 'efghij',\n    'ghijkl', 'hijklm', 'ijklmn', 'jklmno', 'klmnop',\n    'lmnopq', 'mnopqr', 'nopqrs', 'opqrst', 'pqrstu',\n    'qrstuv', 'rstuvw', 'stuvwx', 'tuvwxy', 'uvwxyz',\n    'qwerty', 'wertyu', 'ertyui', 'rtyuio', 'tyuiop',\n    'asdfgh', 'sdfghj', 'dfghjk', 'fghjkl', 'ghjklz'\n  ];\n  \n  return sequences.some(seq => password.toLowerCase().includes(seq));\n}\n\n/**\n * Check if password has more than 2 consecutive identical characters\n */\nfunction hasRepeatedCharacters(password: string): boolean {\n  for (let i = 0; i < password.length - 2; i++) {\n    if (password[i] === password[i + 1] && password[i] === password[i + 2]) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Validate password strength and return detailed feedback\n */\nexport function validatePassword(password: string): PasswordStrength {\n  const requirements: PasswordRequirement[] = [\n    {\n      id: 'length',\n      label: 'At least 12 characters',\n      test: (pwd) => pwd.length >= 12,\n      met: false\n    },\n    {\n      id: 'uppercase',\n      label: 'At least one uppercase letter (A-Z)',\n      test: (pwd) => /[A-Z]/.test(pwd),\n      met: false\n    },\n    {\n      id: 'lowercase',\n      label: 'At least one lowercase letter (a-z)',\n      test: (pwd) => /[a-z]/.test(pwd),\n      met: false\n    },\n    {\n      id: 'numbers',\n      label: 'At least one number (0-9)',\n      test: (pwd) => /\\d/.test(pwd),\n      met: false\n    },\n    {\n      id: 'special',\n      label: 'At least one special character (!@#$%^&*()_+-=[]{}|;:,.<>?)',\n      test: (pwd) => /[!@#$%^&*()_+\\-=\\[\\]{}|;:,.<>?]/.test(pwd),\n      met: false\n    },\n    {\n      id: 'common',\n      label: 'Not a common password',\n      test: (pwd) => !COMMON_PASSWORDS.includes(pwd.toLowerCase()),\n      met: false\n    },\n    {\n      id: 'sequential',\n      label: 'No sequential patterns',\n      test: (pwd) => !hasSequentialPatterns(pwd),\n      met: false\n    },\n    {\n      id: 'repeated',\n      label: 'No more than 2 consecutive identical characters',\n      test: (pwd) => !hasRepeatedCharacters(pwd),\n      met: false\n    }\n  ];\n\n  // Test each requirement\n  requirements.forEach(req => {\n    req.met = req.test(password);\n  });\n\n  // Calculate strength score (0-5)\n  const metRequirements = requirements.filter(req => req.met).length;\n  const totalRequirements = requirements.length;\n  const score = Math.floor((metRequirements / totalRequirements) * 5);\n\n  // Determine strength label and color\n  let label: string;\n  let color: string;\n\n  if (score === 0) {\n    label = 'Very Weak';\n    color = 'text-red-500';\n  } else if (score === 1) {\n    label = 'Weak';\n    color = 'text-orange-500';\n  } else if (score === 2) {\n    label = 'Fair';\n    color = 'text-yellow-500';\n  } else if (score === 3) {\n    label = 'Good';\n    color = 'text-blue-500';\n  } else if (score === 4) {\n    label = 'Strong';\n    color = 'text-green-500';\n  } else {\n    label = 'Very Strong';\n    color = 'text-emerald-500';\n  }\n\n  return {\n    score,\n    label,\n    color,\n    requirements\n  };\n}\n\n/**\n * Check if password meets all requirements\n */\nexport function isPasswordValid(password: string): boolean {\n  const strength = validatePassword(password);\n  return strength.requirements.every(req => req.met);\n}\n","/**\n * Authentication utilities for connecting React components to the auth service\n */\n\nimport { isPasswordValid } from './utils';\n\nexport interface User {\n  id: string;\n  email: string;\n  firstName: string;\n  lastName: string;\n  createdAt: string;\n}\n\nexport interface Session {\n  id: string;\n  token: string;\n  expiresAt: string;\n  refreshToken?: string; // Add refresh token support\n}\n\nexport interface AuthResponse {\n  success: boolean;\n  message?: string;\n  error?: string;\n  user?: User;\n  session?: Session;\n}\n\nexport interface LoginData {\n  email: string;\n  password: string;\n}\n\nexport interface SignupData {\n  email: string;\n  password: string;\n  firstName: string;\n  lastName: string;\n}\n\n// Session management configuration\ninterface SessionConfig {\n  refreshThreshold: number; // Minutes before expiration to refresh token\n  checkInterval: number; // How often to check session status (minutes)\n  maxRefreshAttempts: number; // Maximum refresh attempts before logout\n}\n\nclass AuthClient {\n  private baseUrl: string;\n  private csrfToken: string | null = null;\n  private csrfTokenExpiresAt: number | null = null;\n  private isDevelopment: boolean;\n  private sessionCheckInterval: NodeJS.Timeout | null = null;\n  private refreshAttempts: number = 0;\n  private isRefreshing: boolean = false;\n  private refreshPromise: Promise<boolean> | null = null;\n  \n  // Session management configuration\n  private sessionConfig: SessionConfig = {\n    refreshThreshold: 5, // Refresh 5 minutes before expiration\n    checkInterval: 1, // Check every minute\n    maxRefreshAttempts: 3\n  };\n\n  constructor(baseUrl?: string) {\n    // In development, allow overriding the auth service URL\n    if (baseUrl) {\n      this.baseUrl = baseUrl;\n    } else if (typeof window !== 'undefined') {\n      // Use current domain (auth service is already running at /auth)\n      this.baseUrl = window.location.origin;\n    } else {\n      this.baseUrl = '';\n    }\n    \n    this.isDevelopment = import.meta.env.DEV;\n    \n    // Initialize session management asynchronously\n    if (typeof window !== 'undefined') {\n      // Use setTimeout to ensure this runs after the constructor completes\n      setTimeout(() => {\n        this.initializeSessionManagement().catch(error => {\n          console.error('Failed to initialize session management:', error);\n        });\n      }, 0);\n    }\n  }\n\n  /**\n   * Initialize session management and start monitoring\n   */\n  private async initializeSessionManagement(): Promise<void> {\n    if (typeof window === 'undefined') return;\n\n    // Validate session with server before starting monitoring\n    if (this.isAuthenticated()) {\n      try {\n        const isValid = await this.validateSession();\n        if (!isValid) {\n          // Session is invalid, clear it and don't start monitoring\n          console.log('Session validation failed on initialization, clearing session');\n          this.logout();\n          return;\n        }\n        console.log('Session validated successfully on initialization');\n      } catch (error) {\n        console.error('Session validation error on initialization:', error);\n        // On error, clear the session to be safe\n        this.logout();\n        return;\n      }\n      \n      // Only start monitoring if session is valid\n      this.startSessionMonitoring();\n    }\n\n    // Listen for storage changes (other tabs logging in/out)\n    window.addEventListener('storage', this.handleStorageChange.bind(this));\n    \n    // Listen for page visibility changes to refresh session when tab becomes active\n    document.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));\n  }\n\n  /**\n   * Handle storage changes from other tabs\n   */\n  private handleStorageChange(event: StorageEvent): void {\n    console.log('ðŸ”§ Storage event detected:', {\n      key: event.key,\n      oldValue: event.oldValue ? 'present' : 'null',\n      newValue: event.newValue ? 'present' : 'null',\n      url: event.url,\n      timestamp: new Date().toISOString()\n    });\n    \n    if (event.key === 'auth_token') {\n      if (event.newValue) {\n        // Token was added/updated in another tab\n        console.log('ðŸ”§ Token added/updated in another tab');\n        this.startSessionMonitoring();\n      } else {\n        // Token was removed in another tab\n        console.log('ðŸ”§ Token removed in another tab - stopping monitoring');\n        this.stopSessionMonitoring();\n      }\n    }\n  }\n\n  /**\n   * Handle page visibility changes\n   */\n  private handleVisibilityChange(): void {\n    if (!document.hidden && this.isAuthenticated()) {\n      // Page became visible, check if session needs refresh\n      this.checkAndRefreshSession();\n    }\n  }\n\n  /**\n   * Start monitoring session status\n   */\n  private startSessionMonitoring(): void {\n    console.log('ðŸ”§ Starting session monitoring:', {\n      timestamp: new Date().toISOString(),\n      hadExistingInterval: !!this.sessionCheckInterval\n    });\n    \n    if (this.sessionCheckInterval) {\n      clearInterval(this.sessionCheckInterval);\n    }\n\n    this.sessionCheckInterval = setInterval(() => {\n      this.checkAndRefreshSession();\n    }, this.sessionConfig.checkInterval * 60 * 1000);\n\n    // Add a delay before the first check to give the auth service time to process\n    // This prevents immediate validation right after login\n    setTimeout(() => {\n      console.log('ðŸ”§ Delayed first session check (after 2 second delay)');\n      this.checkAndRefreshSession();\n    }, 2000); // 2 second delay\n  }\n\n  /**\n   * Stop monitoring session status\n   */\n  private stopSessionMonitoring(): void {\n    console.log('ðŸ”§ Stopping session monitoring:', {\n      timestamp: new Date().toISOString(),\n      hadInterval: !!this.sessionCheckInterval\n    });\n    \n    if (this.sessionCheckInterval) {\n      clearInterval(this.sessionCheckInterval);\n      this.sessionCheckInterval = null;\n    }\n  }\n\n  /**\n   * Check if session needs refresh and handle accordingly\n   */\n  private async checkAndRefreshSession(): Promise<void> {\n    console.log('ðŸ”§ Session check started:', {\n      timestamp: new Date().toISOString(),\n      isAuthenticated: this.isAuthenticated()\n    });\n    \n    if (!this.isAuthenticated()) {\n      console.log('ðŸ”§ Session check: User not authenticated, stopping monitoring');\n      this.stopSessionMonitoring();\n      return;\n    }\n\n    const session = this.getCurrentSession();\n    if (!session) {\n      console.log('ðŸ”§ Session check: No session found, logging out');\n      this.logout();\n      return;\n    }\n\n    const expiresAt = new Date(session.expiresAt).getTime();\n    const now = Date.now();\n    const timeUntilExpiry = expiresAt - now;\n    const refreshThresholdMs = this.sessionConfig.refreshThreshold * 60 * 1000;\n\n    console.log('ðŸ”§ Session check details:', {\n      sessionId: session.id,\n      expiresAt: session.expiresAt,\n      currentTime: new Date().toISOString(),\n      timeUntilExpiry: Math.round(timeUntilExpiry / 1000 / 60), // minutes\n      refreshThreshold: this.sessionConfig.refreshThreshold, // minutes\n      shouldRefresh: timeUntilExpiry <= refreshThresholdMs,\n      isExpired: timeUntilExpiry <= 0\n    });\n\n    if (timeUntilExpiry <= 0) {\n      // Session has expired\n      console.log('ðŸ”§ Session check: Session has expired, logging out');\n      this.logout();\n      this.emitSessionExpired();\n    } else if (timeUntilExpiry <= refreshThresholdMs) {\n      // Session is about to expire, refresh it\n      console.log(`ðŸ”§ Session check: Session expiring in ${Math.round(timeUntilExpiry / 1000 / 60)} minutes, refreshing token`);\n      const refreshSuccess = await this.refreshSession();\n      if (!refreshSuccess) {\n        console.log('ðŸ”§ Session check: Session refresh failed, logging out');\n        this.logout();\n        this.emitSessionExpired();\n      }\n    } else {\n      // Session is still valid, but let's validate it with the server periodically\n      // Only validate every 5 minutes to avoid too many requests\n      const lastValidation = localStorage.getItem('auth_last_validation');\n      const now = Date.now();\n      const validationInterval = 5 * 60 * 1000; // 5 minutes\n      \n      if (!lastValidation || (now - parseInt(lastValidation)) > validationInterval) {\n        console.log('ðŸ”§ Session check: Performing periodic session validation');\n        const isValid = await this.validateSession();\n        if (isValid) {\n          localStorage.setItem('auth_last_validation', now.toString());\n          console.log('ðŸ”§ Session check: Periodic validation successful');\n        } else {\n          console.log('ðŸ”§ Session check: Periodic validation failed');\n          this.logout();\n          this.emitSessionExpired();\n        }\n      } else {\n        console.log('ðŸ”§ Session check: Skipping validation (too recent)');\n      }\n    }\n  }\n\n  /**\n   * Refresh the current session\n   */\n  private async refreshSession(): Promise<boolean> {\n    // Prevent multiple simultaneous refresh attempts\n    if (this.isRefreshing) {\n      return this.refreshPromise!;\n    }\n\n    if (this.refreshAttempts >= this.sessionConfig.maxRefreshAttempts) {\n      console.log('Max refresh attempts reached, logging out');\n      this.logout();\n      this.emitSessionExpired();\n      return false;\n    }\n\n    this.isRefreshing = true;\n    this.refreshAttempts++;\n\n    this.refreshPromise = this.performRefresh();\n    \n    try {\n      const success = await this.refreshPromise;\n      if (success) {\n        this.refreshAttempts = 0; // Reset attempts on successful refresh\n      }\n      return success;\n    } finally {\n      this.isRefreshing = false;\n      this.refreshPromise = null;\n    }\n  }\n\n  /**\n   * Perform the actual refresh operation\n   */\n  private async performRefresh(): Promise<boolean> {\n    const session = this.getCurrentSession();\n    if (!session?.refreshToken) {\n      console.log('No refresh token available');\n      return false;\n    }\n\n    if (this.shouldUseMock()) {\n      // Mock refresh - generate new session\n      const newSession = this.generateMockSession();\n      localStorage.setItem('auth_token', newSession.token);\n      localStorage.setItem('auth_session', JSON.stringify(newSession));\n      console.log('Mock session refreshed');\n      return true;\n    }\n\n    try {\n      const response = await fetch(`${this.baseUrl}/auth/refresh`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          refreshToken: session.refreshToken,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Refresh failed: ${response.status}`);\n      }\n\n      const data: AuthResponse = await response.json();\n      \n      if (data.success && data.session) {\n        // Update stored session\n        localStorage.setItem('auth_token', data.session.token);\n        localStorage.setItem('auth_session', JSON.stringify(data.session));\n        \n        // Update user if provided\n        if (data.user) {\n          localStorage.setItem('auth_user', JSON.stringify(data.user));\n        }\n        \n        console.log('Session refreshed successfully');\n        return true;\n      }\n\n      return false;\n    } catch (error) {\n      console.error('Session refresh failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get current session from localStorage\n   */\n  getCurrentSession(): Session | null {\n    if (typeof window === 'undefined') return null;\n    \n    const sessionStr = localStorage.getItem('auth_session');\n    if (!sessionStr) return null;\n    \n    try {\n      return JSON.parse(sessionStr) as Session;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Emit session expired event\n   */\n  private emitSessionExpired(): void {\n    // Dispatch custom event for components to listen to\n    if (typeof window !== 'undefined') {\n      window.dispatchEvent(new CustomEvent('sessionExpired'));\n    }\n  }\n\n  /**\n   * Check if we're in development mode and should use mock responses\n   */\n  private shouldUseMock(): boolean {\n    // In development, use mock mode if we're on localhost\n    return this.isDevelopment && (\n      this.baseUrl.includes('localhost') ||\n      this.baseUrl.includes('127.0.0.1')\n    );\n  }\n\n  /**\n   * Check if current CSRF token is valid and not expired\n   */\n  private isCSRFTokenValid(): boolean {\n    if (!this.csrfToken || !this.csrfTokenExpiresAt) {\n      return false;\n    }\n    \n    // Add 5 minute buffer before expiration\n    const bufferTime = 5 * 60 * 1000; // 5 minutes in milliseconds\n    return Date.now() < (this.csrfTokenExpiresAt - bufferTime);\n  }\n\n  /**\n   * Generate mock user data\n   */\n  private generateMockUser(data: { email: string; firstName?: string; lastName?: string }): User {\n    return {\n      id: `mock-${Date.now()}`,\n      email: data.email,\n      firstName: data.firstName || 'Mock',\n      lastName: data.lastName || 'User',\n      createdAt: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Generate mock session data\n   */\n  private generateMockSession(): Session {\n    return {\n      id: `session-${Date.now()}`,\n      token: `mock-token-${Date.now()}`,\n      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // 24 hours\n      refreshToken: `mock-refresh-${Date.now()}`,\n    };\n  }\n\n  /**\n   * Get CSRF token for form protection\n   */\n  async getCSRFToken(): Promise<string> {\n    if (this.shouldUseMock()) {\n      this.csrfToken = `mock-csrf-${Date.now()}`;\n      this.csrfTokenExpiresAt = Date.now() + 60 * 60 * 1000; // 1 hour for mock tokens\n      return this.csrfToken;\n    }\n\n    try {\n      const response = await fetch(`${this.baseUrl}/auth/csrf-token`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error(`Failed to get CSRF token: ${response.status} ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      this.csrfToken = data.token;\n      \n      // Set expiration time (default to 1 hour if not provided)\n      this.csrfTokenExpiresAt = data.expiresAt \n        ? new Date(data.expiresAt).getTime()\n        : Date.now() + 60 * 60 * 1000; // 1 hour default\n      \n      return data.token;\n    } catch (error) {\n      console.error('Error getting CSRF token:', error);\n      if (this.isDevelopment) {\n        console.warn('Using mock CSRF token for development');\n        this.csrfToken = `mock-csrf-${Date.now()}`;\n        this.csrfTokenExpiresAt = Date.now() + 60 * 60 * 1000; // 1 hour for mock tokens\n        return this.csrfToken;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Ensure we have a valid CSRF token, refreshing if necessary\n   */\n  private async ensureValidCSRFToken(): Promise<string> {\n    if (!this.isCSRFTokenValid()) {\n      console.log('CSRF token expired or invalid, refreshing...');\n      await this.getCSRFToken();\n    }\n    return this.csrfToken!;\n  }\n\n  /**\n   * Make an authenticated request with CSRF token refresh retry logic\n   */\n  private async makeAuthenticatedRequest<T>(\n    url: string, \n    options: RequestInit, \n    retryCount: number = 0\n  ): Promise<T> {\n    const maxRetries = 1; // Only retry once to avoid infinite loops\n    \n    try {\n      // Ensure we have a valid CSRF token\n      const csrfToken = await this.ensureValidCSRFToken();\n      \n      // Add CSRF token to request body if it's a POST/PUT/PATCH request\n      if (options.body && typeof options.body === 'string') {\n        const bodyData = JSON.parse(options.body);\n        bodyData.csrfToken = csrfToken;\n        options.body = JSON.stringify(bodyData);\n      }\n\n      const response = await fetch(url, options);\n      \n      // If we get a 401/403, it might be due to expired CSRF token\n      if ((response.status === 401 || response.status === 403) && retryCount < maxRetries) {\n        console.log(`Request failed with ${response.status}, refreshing CSRF token and retrying...`);\n        \n        // Clear current token and get a fresh one\n        this.csrfToken = null;\n        this.csrfTokenExpiresAt = null;\n        \n        // Retry the request\n        return this.makeAuthenticatedRequest(url, options, retryCount + 1);\n      }\n      \n      if (!response.ok) {\n        throw new Error(`Request failed: ${response.status} ${response.statusText}`);\n      }\n      \n      return await response.json();\n    } catch (error) {\n      if (retryCount < maxRetries) {\n        console.log('Request failed, refreshing CSRF token and retrying...');\n        this.csrfToken = null;\n        this.csrfTokenExpiresAt = null;\n        return this.makeAuthenticatedRequest(url, options, retryCount + 1);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Check if user is authenticated\n   */\n  isAuthenticated(): boolean {\n    if (typeof window === 'undefined') return false;\n    const token = localStorage.getItem('auth_token');\n    console.log('ðŸ”§ isAuthenticated check:', {\n      hasToken: !!token,\n      tokenLength: token?.length,\n      timestamp: new Date().toISOString(),\n      stack: new Error().stack?.split('\\n').slice(1, 4).join(' | ') // Show call stack\n    });\n    return !!token;\n  }\n\n  /**\n   * Get current user from localStorage\n   */\n  getCurrentUser(): User | null {\n    if (typeof window === 'undefined') return null;\n    \n    const userStr = localStorage.getItem('auth_user');\n    if (!userStr) return null;\n    \n    try {\n      return JSON.parse(userStr) as User;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Get session expiration time\n   */\n  getSessionExpiration(): Date | null {\n    const session = this.getCurrentSession();\n    return session ? new Date(session.expiresAt) : null;\n  }\n\n  /**\n   * Check if session is about to expire\n   */\n  isSessionExpiringSoon(): boolean {\n    const session = this.getCurrentSession();\n    if (!session) return false;\n\n    const expiresAt = new Date(session.expiresAt).getTime();\n    const now = Date.now();\n    const refreshThresholdMs = this.sessionConfig.refreshThreshold * 60 * 1000;\n\n    return (expiresAt - now) <= refreshThresholdMs;\n  }\n\n  /**\n   * Check if user opted to stay signed in\n   */\n  isStaySignedInEnabled(): boolean {\n    if (typeof window === 'undefined') return false;\n    return localStorage.getItem('auth_stay_signed_in') === 'true';\n  }\n\n  /**\n   * Get time until session expires\n   */\n  getTimeUntilExpiration(): number {\n    const session = this.getCurrentSession();\n    if (!session) return 0;\n\n    const expiresAt = new Date(session.expiresAt).getTime();\n    const now = Date.now();\n    return Math.max(0, expiresAt - now);\n  }\n\n  /**\n   * Get formatted time until expiration\n   */\n  getFormattedTimeUntilExpiration(): string {\n    const timeMs = this.getTimeUntilExpiration();\n    if (timeMs === 0) return 'Expired';\n\n    const hours = Math.floor(timeMs / (1000 * 60 * 60));\n    const minutes = Math.floor((timeMs % (1000 * 60 * 60)) / (1000 * 60));\n\n    if (hours > 0) {\n      return `${hours}h ${minutes}m`;\n    } else if (minutes > 0) {\n      return `${minutes}m`;\n    } else {\n      return 'Less than 1m';\n    }\n  }\n\n  /**\n   * Login user\n   */\n  async login(loginData: LoginData, staySignedIn: boolean = true): Promise<User> {\n    console.log('ðŸ”§ Auth login called with:', { \n      isDevelopment: this.isDevelopment, \n      baseUrl: this.baseUrl, \n      shouldUseMock: this.shouldUseMock(),\n      staySignedIn\n    });\n\n    if (this.shouldUseMock()) {\n      console.log('ðŸ”§ Using mock login');\n      // Simulate network delay\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      // Mock validation\n      if (!loginData.email || !loginData.password) {\n        throw new Error('Email and password are required');\n      }\n\n      const user = this.generateMockUser({ email: loginData.email });\n      const session = this.generateMockSession();\n      \n      // Store in localStorage\n      localStorage.setItem('auth_token', session.token);\n      localStorage.setItem('auth_user', JSON.stringify(user));\n      localStorage.setItem('auth_session', JSON.stringify(session));\n      localStorage.setItem('auth_stay_signed_in', staySignedIn.toString());\n      \n      // Start session monitoring\n      this.startSessionMonitoring();\n      \n      console.log('ðŸ”§ Mock login successful:', user);\n      return user;\n    }\n\n    console.log('ðŸ”§ Using real auth service login');\n\n    try {\n      console.log('ðŸ”§ Making login request to:', `${this.baseUrl}/auth/login`);\n      \n      const data: AuthResponse = await this.makeAuthenticatedRequest<AuthResponse>(\n        `${this.baseUrl}/auth/login`,\n        {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify(loginData),\n        }\n      );\n\n      console.log('ðŸ”§ Login server response:', {\n        success: data.success,\n        hasSession: !!data.session,\n        hasUser: !!data.user,\n        sessionId: data.session?.id,\n        sessionTokenLength: data.session?.token?.length,\n        sessionExpiresAt: data.session?.expiresAt,\n        error: data.error\n      });\n\n      if (data.success && data.session && data.user) {\n        // Store session token in localStorage\n        console.log('ðŸ”§ Login - storing token:', {\n          tokenLength: data.session.token.length,\n          sessionId: data.session.id,\n          expiresAt: data.session.expiresAt,\n          hasRefreshToken: !!data.session.refreshToken\n        });\n        \n        localStorage.setItem('auth_token', data.session.token);\n        localStorage.setItem('auth_user', JSON.stringify(data.user));\n        localStorage.setItem('auth_session', JSON.stringify(data.session));\n        localStorage.setItem('auth_stay_signed_in', staySignedIn.toString());\n        \n        // Verify storage immediately\n        const storedToken = localStorage.getItem('auth_token');\n        const storedSession = localStorage.getItem('auth_session');\n        console.log('ðŸ”§ Login - storage verification:', {\n          tokenMatches: storedToken === data.session.token,\n          tokenLength: storedToken?.length,\n          sessionStored: !!storedSession\n        });\n        \n        // Start session monitoring\n        this.startSessionMonitoring();\n        \n        return data.user;\n      }\n\n      throw new Error(data.error || 'Login failed');\n    } catch (error) {\n      console.error('Login failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Register new user\n   */\n  async signup(signupData: SignupData): Promise<User> {\n    console.log('ðŸ”§ Auth signup called with:', { \n      isDevelopment: this.isDevelopment, \n      baseUrl: this.baseUrl, \n      shouldUseMock: this.shouldUseMock() \n    });\n\n    if (this.shouldUseMock()) {\n      console.log('ðŸ”§ Using mock signup');\n      // Simulate network delay\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      // Mock validation\n      if (!signupData.email || !signupData.password || !signupData.firstName || !signupData.lastName) {\n        throw new Error('All fields are required');\n      }\n      \n      if (!isPasswordValid(signupData.password)) {\n        throw new Error('Password does not meet all requirements');\n      }\n\n      const user = this.generateMockUser(signupData);\n      const session = this.generateMockSession();\n      \n      // Store in localStorage\n      localStorage.setItem('auth_token', session.token);\n      localStorage.setItem('auth_user', JSON.stringify(user));\n      localStorage.setItem('auth_session', JSON.stringify(session));\n      \n      // Start session monitoring\n      this.startSessionMonitoring();\n      \n      console.log('ðŸ”§ Mock registration successful:', user);\n      return user;\n    }\n\n    console.log('ðŸ”§ Using real auth service signup');\n\n    try {\n      const data: AuthResponse = await this.makeAuthenticatedRequest<AuthResponse>(\n        `${this.baseUrl}/auth/signup`,\n        {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify(signupData),\n        }\n      );\n\n      if (data.success && data.session && data.user) {\n        // Store session token in localStorage\n        localStorage.setItem('auth_token', data.session.token);\n        localStorage.setItem('auth_user', JSON.stringify(data.user));\n        localStorage.setItem('auth_session', JSON.stringify(data.session));\n        \n        // Start session monitoring\n        this.startSessionMonitoring();\n        \n        return data.user;\n      }\n\n      throw new Error(data.error || 'Signup failed');\n    } catch (error) {\n      console.error('Signup failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Logout user\n   */\n  async logout(): Promise<void> {\n    if (typeof window === 'undefined') return;\n\n    const token = localStorage.getItem('auth_token');\n    console.log('ðŸ”§ Logout called:', {\n      hadToken: !!token,\n      tokenLength: token?.length,\n      timestamp: new Date().toISOString(),\n      stack: new Error().stack?.split('\\n').slice(1, 4).join(' | ') // Show call stack\n    });\n    \n    if (this.shouldUseMock()) {\n      console.log('ðŸ”§ Mock logout successful');\n    } else if (token) {\n      try {\n        await fetch(`${this.baseUrl}/auth/logout`, {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${token}`,\n            'Content-Type': 'application/json',\n          },\n        });\n      } catch (error) {\n        console.warn('Logout request failed:', error);\n      }\n    }\n\n    // Stop session monitoring\n    this.stopSessionMonitoring();\n    \n    // Clear local storage regardless of API call success\n    localStorage.removeItem('auth_token');\n    localStorage.removeItem('auth_user');\n    localStorage.removeItem('auth_session');\n    localStorage.removeItem('auth_stay_signed_in');\n    localStorage.removeItem('auth_last_validation'); // Clear validation timestamp\n    this.csrfToken = null; // Clear CSRF token on logout\n    this.csrfTokenExpiresAt = null; // Clear CSRF token expiration on logout\n    \n    // Reset refresh attempts\n    this.refreshAttempts = 0;\n    \n    console.log('ðŸ”§ Logout completed - all tokens cleared');\n  }\n\n  /**\n   * Validate current session\n   */\n  async validateSession(): Promise<boolean> {\n    if (typeof window === 'undefined') return false;\n\n    const token = localStorage.getItem('auth_token');\n    if (!token) return false;\n\n    if (this.shouldUseMock()) {\n      // Mock session validation - always return true if token exists\n      return true;\n    }\n\n    try {\n      // Get the full session data for comparison\n      const session = this.getCurrentSession();\n      console.log('ðŸ”§ Session validation - full debug info:', {\n        tokenLength: token.length,\n        sessionId: session?.id,\n        sessionExpiresAt: session?.expiresAt,\n        hasRefreshToken: !!session?.refreshToken,\n        currentTime: new Date().toISOString(),\n        isExpired: session ? new Date(session.expiresAt) < new Date() : null\n      });\n      \n      const response = await fetch(`${this.baseUrl}/auth/session`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json',\n        },\n      });\n\n      console.log('ðŸ”§ Session validation response:', {\n        status: response.status,\n        statusText: response.statusText,\n        ok: response.ok,\n        headers: Object.fromEntries(response.headers.entries())\n      });\n\n      if (!response.ok) {\n        // Try to get the full error response\n        let errorDetails = '';\n        try {\n          errorDetails = await response.text();\n          console.warn('ðŸ”§ Session validation error response:', errorDetails);\n        } catch (e) {\n          console.warn('ðŸ”§ Could not read error response body');\n        }\n        \n        console.warn(`Session validation failed with status: ${response.status}`);\n        \n        // Clear invalid session\n        this.logout();\n        return false;\n      }\n\n      const data: AuthResponse = await response.json();\n\n      if (!data.success) {\n        console.warn('Session validation failed:', data.error || 'Unknown error');\n        // Clear invalid session\n        this.logout();\n        return false;\n      }\n\n      console.log('ðŸ”§ Session validation successful');\n      return true;\n    } catch (error) {\n      console.warn('Session validation failed:', error);\n      // Don't clear session on network errors, only on validation errors\n      // This prevents clearing session when the server is temporarily unavailable\n      if (error instanceof TypeError && error.message.includes('fetch')) {\n        console.log('Network error during session validation, keeping session');\n        return false; // Return false but don't logout\n      }\n      \n      // For other errors, clear the session\n      this.logout();\n      return false;\n    }\n  }\n\n  /**\n   * Validate session on app startup - this should be called when the app first loads\n   */\n  async validateSessionOnStartup(): Promise<boolean> {\n    if (typeof window === 'undefined') return false;\n\n    const token = localStorage.getItem('auth_token');\n    if (!token) {\n      console.log('No auth token found on startup');\n      return false;\n    }\n\n    console.log('Validating session on app startup...');\n    console.log('Token exists:', !!token);\n    \n    try {\n      const isValid = await this.validateSession();\n      if (isValid) {\n        console.log('Session is valid on startup, starting session monitoring');\n        this.startSessionMonitoring();\n      } else {\n        console.log('Session is invalid on startup, user will need to log in again');\n      }\n      return isValid;\n    } catch (error) {\n      console.error('Session validation error on startup:', error);\n      this.logout();\n      return false;\n    }\n  }\n\n  /**\n   * Health check for auth service\n   */\n  async healthCheck(): Promise<any> {\n    if (this.shouldUseMock()) {\n      return {\n        status: 200,\n        domain: 'localhost',\n        subdomain: 'mock',\n        timestamp: new Date().toISOString(),\n        mock: true\n      };\n    }\n\n    try {\n      const response = await fetch(`${this.baseUrl}/auth/health`, {\n        method: 'GET',\n      });\n      return await response.json();\n    } catch (error) {\n      console.error('Health check failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get the current base URL (useful for debugging)\n   */\n  getBaseUrl(): string {\n    return this.baseUrl;\n  }\n\n  /**\n   * Check if we're using mock mode\n   */\n  isMockMode(): boolean {\n    return this.shouldUseMock();\n  }\n\n  /**\n   * Manually refresh CSRF token\n   */\n  async refreshCSRFToken(): Promise<string> {\n    this.csrfToken = null;\n    this.csrfTokenExpiresAt = null;\n    return await this.getCSRFToken();\n  }\n\n  /**\n   * Check if current CSRF token is valid (public method)\n   */\n  isCSRFTokenValidPublic(): boolean {\n    return this.isCSRFTokenValid();\n  }\n\n  /**\n   * Get CSRF token expiration time (for debugging)\n   */\n  getCSRFTokenExpiration(): Date | null {\n    return this.csrfTokenExpiresAt ? new Date(this.csrfTokenExpiresAt) : null;\n  }\n\n  /**\n   * Update session configuration\n   */\n  updateSessionConfig(config: Partial<SessionConfig>): void {\n    this.sessionConfig = { ...this.sessionConfig, ...config };\n    \n    // Restart monitoring with new config if currently monitoring\n    if (this.sessionCheckInterval) {\n      this.startSessionMonitoring();\n    }\n  }\n\n  /**\n   * Get current session configuration\n   */\n  getSessionConfig(): SessionConfig {\n    return { ...this.sessionConfig };\n  }\n\n  /**\n   * Manually trigger session validation (for debugging)\n   */\n  async debugValidateSession(): Promise<{ isValid: boolean; error?: string; details?: any }> {\n    if (typeof window === 'undefined') {\n      return { isValid: false, error: 'Not in browser environment' };\n    }\n\n    const token = localStorage.getItem('auth_token');\n    if (!token) {\n      return { isValid: false, error: 'No token found' };\n    }\n\n    if (this.shouldUseMock()) {\n      return { isValid: true, details: { mode: 'mock' } };\n    }\n\n    try {\n      const response = await fetch(`${this.baseUrl}/auth/session`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const responseText = await response.text();\n\n      let data: AuthResponse;\n      try {\n        data = JSON.parse(responseText);\n      } catch (parseError) {\n        return { \n          isValid: false, \n          error: 'Invalid JSON response', \n          details: { responseText, parseError } \n        };\n      }\n\n      return { \n        isValid: data.success, \n        error: data.error,\n        details: { data, status: response.status }\n      };\n    } catch (error) {\n      return { \n        isValid: false, \n        error: error instanceof Error ? error.message : 'Unknown error',\n        details: { error }\n      };\n    }\n  }\n\n  /**\n   * Cleanup method to be called when the app unmounts\n   */\n  cleanup(): void {\n    this.stopSessionMonitoring();\n    \n    if (typeof window !== 'undefined') {\n      window.removeEventListener('storage', this.handleStorageChange.bind(this));\n      document.removeEventListener('visibilitychange', this.handleVisibilityChange.bind(this));\n    }\n  }\n\n  /**\n   * Test auth service connectivity and get detailed error info\n   */\n  async testAuthServiceDetailed(): Promise<{ \n    reachable: boolean; \n    error?: string; \n    details?: any;\n    sessionEndpoint?: any;\n  }> {\n    if (this.shouldUseMock()) {\n      return { reachable: true, details: { mode: 'mock' } };\n    }\n\n    try {\n      console.log('ðŸ”§ Testing auth service connectivity...');\n      \n      // Test health endpoint\n      const healthResponse = await fetch(`${this.baseUrl}/auth/health`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n\n      console.log('ðŸ”§ Health check response:', {\n        status: healthResponse.status,\n        ok: healthResponse.ok\n      });\n\n      let healthData = null;\n      if (healthResponse.ok) {\n        try {\n          healthData = await healthResponse.json();\n        } catch (e) {\n          healthData = 'Non-JSON response';\n        }\n      }\n\n      // Test session endpoint with a dummy token to see the error format\n      const dummyToken = 'dummy-token-for-testing';\n      const sessionResponse = await fetch(`${this.baseUrl}/auth/session`, {\n        method: 'GET',\n        headers: {\n          'Authorization': `Bearer ${dummyToken}`,\n          'Content-Type': 'application/json',\n        },\n      });\n\n      let sessionError = null;\n      if (!sessionResponse.ok) {\n        try {\n          sessionError = await sessionResponse.text();\n        } catch (e) {\n          sessionError = 'Could not read error response';\n        }\n      }\n\n      return { \n        reachable: healthResponse.ok,\n        details: { \n          health: healthData,\n          healthStatus: healthResponse.status\n        },\n        sessionEndpoint: {\n          status: sessionResponse.status,\n          error: sessionError\n        }\n      };\n    } catch (error) {\n      console.error('ðŸ”§ Auth service connectivity test failed:', error);\n      return { \n        reachable: false, \n        error: error instanceof Error ? error.message : 'Unknown error',\n        details: { error }\n      };\n    }\n  }\n}\n\n// Export a default instance\nexport const auth = new AuthClient(); "],"names":["now"],"mappings":"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"}